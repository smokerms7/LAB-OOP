# Лабораторная работа №11. Алгоритмы
## Выполнил: Хизриев Магомед-Салах Алиевич, группа ПИЖ-б-о-23-2-(1)
### Вариант: 7

Тема проекта: приложение "Учёт денежных средств". 
В приложении должно быть реализовано 2 класса: Журнал учёта и Платёж. Класс Журнал содержит карту, имя. Класс Платёж содержит дату, сумму, описание

# Задание:
1. Дополнить и при необходимости модифицировать приложение, разработанное согласно варианту лабораторной работы № 3. 
2. Создать контейнер, содержащий объекты пользовательского типа. Тип контейнера выбирается в соответствии с вариантом задания.
3. Отсортировать его по убыванию элементов.
4. Просмотреть контейнер.
5. Используя подходящий алгоритм, найти в контейнере элемент, удовлетворяющий заданному условию.
6. Переместить элементы, удовлетворяющие заданному условию в другой (предварительно пустой) контейнер. Тип второго контейнера определяется вариантом задания.
7. Просмотреть второй контейнер.
8. Отсортировать первый и второй контейнеры по возрастанию 
элементов.
9. Просмотреть их. 
10. Сделать выводы.

# Теоретическая информация 

Каждый алгоритм выражается шаблоном функции или набором шаблонов функций. Алгоритмы определены в <algorithm.h>. Часто используемые функции-алгоритмов STL:
1. Немодифицирующие операции:
- for_earch() выполняет операции для каждого элемента последовательности
- find() находит первое вхождение значения в последовательность
- find_if() находит первое соответствие предикату в последовательности
- count() подсчитывает количество вхождений значения в последовательность
- count_if() подсчитывает количество выполнений предиката в последовательности
- search() находит первое вхождение последовательности как подпоследовательности
- search_n() находит n-е вхождение значения в последовательность
2. Модифицирующие операции:
- copy() копирует последовательность, начиная с первого элемента
- swap() меняет местами два элемента 
- replace() заменяет элементы с указанным значением 
- replace_if() заменяет элементы при выполнении предиката
- replace_copy() копирует последовательность, заменяя элементы с указанным значением
- replace_copy_if() копирует последовательность, заменяя элементы при выполнении предиката
- fill() заменяет все элементы данным значением
- remove() удаляет элементы с данным значением
- remove_if() удаляет элементы при выполнении предиката
- remove_copy() копирует последовательность, удаляя элементы с указанным значением
- remove_copy_if() копирует последовательность, удаляя элементы при выполнении предиката
- reverse() меняет порядок следования элементов на обратный
- random_shuffle() перемещает элементы согласно случайному равномерному распределению («тасует» последовательность)
- transform() выполняет заданную операцию над каждым элементом последовательности
- unique() удаляет равные соседние элементы
- unique_copy() копирует последовательность, удаляя равные соседние элементы
3. Сортировка:
- sort() сортирует последовательность с хорошей средней эффективностью
- partial_sort() сортирует часть последовательности
- stable_sort() сортирует последовательность, сохраняя порядок следования равных элементов
- lower_bound() находит первое вхождение значения в отсортированной последовательности
- upper_bound() находит первый элемент, больший чем заданное значение
- binary_search() определяет, есть ли данный элемент в отсортированной последовательности 
- merge() сливает две отсортированные последовательности
4. Работа с множествами:
- includes() проверка на вхождение 
- set_union() объединение множеств
- set_intersection() пересечение множеств
- set_difference() разность множеств
5. Минимумы и максимумы:
- min() меньшее из двух
- max() большее из двух
- min_element() наименьшее значение в последовательности
- max_element() наибольшее значение в последовательности
6. Перестановки:
- next_permutation() следующая перестановка в лексикографическом порядке
- pred_permutation() предыдущая перестановка в лексикографическом порядке

# Листинг программы 

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

// Базовый класс - Платеж
class Payment {
protected:
    string date;
    double amount;
    string description;

public:
    Payment() : date("01.01.1970"), amount(0.0), description("Без описания") {}
    Payment(string d, double a, string desc) : date(d), amount(a), description(desc) {}

    virtual ~Payment() {}

    double getAmount() const { return amount; }

    virtual void print() const {
        cout << "Дата: " << date << ", Сумма: " << amount << ", Описание: " << description << endl;
    }
};

// Класс-наследник 1: Доходы
class Income : public Payment {
public:
    Income(string d, double a, string desc) : Payment(d, a, desc) {}
    void print() const override {
        cout << "Доход - ";
        Payment::print();
    }
};

// Класс-наследник 2: Расходы
class Expense : public Payment {
public:
    Expense(string d, double a, string desc) : Payment(d, a, desc) {}
    void print() const override {
        cout << "Расход - ";
        Payment::print();
    }
};

// Функция для сравнения платежей по убыванию суммы
bool compareDesc(Payment* a, Payment* b) {
    return a->getAmount() > b->getAmount();
}

// Функция для сравнения платежей по возрастанию суммы
bool compareAsc(Payment* a, Payment* b) {
    return a->getAmount() < b->getAmount();
}

// Основной класс - Журнал учета
class AccountBook {
private:
    string card;
    string name;
    vector<Payment*> payments;

public:
    AccountBook(string c, string n) : card(c), name(n) {}
    ~AccountBook() {
        for (auto payment : payments) {
            delete payment;
        }
    }

    void addPayment(Payment* p) {
        payments.push_back(p);
    }

    void printAllPayments() const {
        cout << "\nЖурнал: " << name << " (карта: " << card << ")" << endl;
        cout << "Список платежей:\n";
        for (size_t i = 0; i < payments.size(); i++) {
            cout << i + 1 << ". ";
            payments[i]->print();
        }
    }
};

int main() {
    setlocale(LC_ALL, "Russian");
    AccountBook book("1234 5678 9012 3456", "Алдабаева В.В.");

    // Создаем и заполняем вектор платежей
    vector<Payment*> payments;
    payments.push_back(new Income("01.06.2023", 50000.0, "Зарплата"));
    payments.push_back(new Expense("02.06.2023", 15000.0, "Аренда"));
    payments.push_back(new Income("05.06.2023", 10000.0, "Фриланс"));
    payments.push_back(new Expense("10.06.2023", 5000.0, "Продукты"));

    // Сортировка по убыванию суммы
    sort(payments.begin(), payments.end(), compareDesc);

    cout << "Платежи отсортированные по убыванию суммы" << endl;
    for (auto p : payments) {
        p->print();
    }

    // Поиск платежей больше 10000 руб.
    vector<Payment*> largePayments;
    for (auto p : payments) {
        if (p->getAmount() > 10000) {
            largePayments.push_back(p);
        }
    }

    cout << "\nПлатежи с суммой > 10000 руб." << endl;
    for (auto p : largePayments) {
        p->print();
    }

    // Добавление всех платежей в журнал
    for (auto p : payments) {
        book.addPayment(p);
    }

    cout << "\nСодержимое журнала после добавления" << endl;
    book.printAllPayments();

    // Сортировка всех платежей по возрастанию суммы
    sort(payments.begin(), payments.end(), compareAsc);

    // Сортировка большого контейнера по возрастанию суммы
    sort(largePayments.begin(), largePayments.end(), compareAsc);

    // Просмотр отсортированных платежей и крупных платежей
    cout << "\nПлатежи после сортировки по возрастанию суммы" << endl;
    for (auto p : payments) {
        p->print();
    }

    cout << "\nКрупные платежи после сортировки по возрастанию суммы" << endl;
    for (auto p : largePayments) {
        p->print();
    }

    return 0;
}
```








